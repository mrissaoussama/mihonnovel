ISSUE: Actually, on first startup the cache may not exist, so force = true is correct for init. Let me leave it.

 only build it if it is empty, dont force build each time otherwise what is the point of a cache?
 The connection pool for database '/data/user/0/app.mihonnovel.dev/databases/tachiyomi.db' has been unable to grant a connection to thread 151 (DefaultDispatcher-worker-5) with flags 0x1 for 240.02501 seconds.
Connections: 1 active, 0 idle, 0 available.

Requests in progress:
  executeForChangedRowCount started 240165ms ago - running, sql="INSERT OR REPLACE INTO library_cache ( manga_id, total_count, read_count, latest_upload, chapter_fetched_at, last_read, bookmark_count, category_ids ) SELECT M._id, coalesce(C.total, 0), coalesce(C.readCount, 0), coalesce(C.latestUpload, 0), coalesce(C.fetchedAt, 0), coalesce(C.lastRead, 0), coalesce(C.bookmarkCount, 0), coalesce(MC.categories, '0') FROM mangas M LEFT JOIN ( SELECT chapters.manga_id, count(*) AS total, sum(read) AS readCount, coalesce(max(chapters.date_upload), 0) AS latestUpload, coalesce(max(history.last_read), 0) AS lastRead, coalesce(max(chapters.date_fetch), 0) AS fetchedAt, sum(chapters.bookmark) AS bookmarkCount FROM chapters LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id AND chapters.scanlator = excluded_scanlators.scanlator LEFT JOIN history ON chapters._id = history.chapter_id WHERE excluded_scanlators.scanlator IS NULL GROUP BY chapters.manga_id ) AS C ON M._id = C.manga_id LEFT JOIN ( SELECT manga_id, group_concat(category_id) AS categories FROM mangas_categories GROUP BY manga_id ) AS MC ON MC.manga_id = M._id WHERE M.favorite = 1", path=/data/user/0/app.mihonnovel.dev/databases/tachiyomi.db
The connection pool for database '/data/user/0/app.mihonnovel.dev/databases/tachiyomi.db' has been unable to grant a connection to thread 119 (DefaultDispatcher-worker-19) with flags 0x1 for 240.02501 seconds.
Connections: 1 active, 0 idle, 0 available.

Requests in progress:
  executeForChangedRowCount started 240170ms ago - running, sql="INSERT OR REPLACE INTO library_cache ( manga_id, total_count, read_count, latest_upload, chapter_fetched_at, last_read, bookmark_count, category_ids ) SELECT M._id, coalesce(C.total, 0), coalesce(C.readCount, 0), coalesce(C.latestUpload, 0), coalesce(C.fetchedAt, 0), coalesce(C.lastRead, 0), coalesce(C.bookmarkCount, 0), coalesce(MC.categories, '0') FROM mangas M LEFT JOIN ( SELECT chapters.manga_id, count(*) AS total, sum(read) AS readCount, coalesce(max(chapters.date_upload), 0) AS latestUpload, coalesce(max(history.last_read), 0) AS lastRead, coalesce(max(chapters.date_fetch), 0) AS fetchedAt, sum(chapters.bookmark) AS bookmarkCount FROM chapters LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id AND chapters.scanlator = excluded_scanlators.scanlator LEFT JOIN history ON chapters._id = history.chapter_id WHERE excluded_scanlators.scanlator IS NULL GROUP BY chapters.manga_id ) AS C ON M._id = C.manga_id LEFT JOIN ( SELECT manga_id, group_concat(category_id) AS categories FROM mangas_categories GROUP BY manga_id ) AS MC ON MC.manga_id = M._id WHERE M.favorite = 1", path=/data/user/0/app.mihonnovel.dev/databases/tachiyomi.db

the cache should be updated when one or multiple columns changem download count, last read,category ids,boookmark count,total count ect 

 getFavoritesFlow(): calls downloadManager.getDownloadCount() per item = O(n) per flow emission
i dont actually mind flow emmisions, should probably be used more , but what should be done with flow emmisions is the issue, like instead of reloading the entire list, reload only relevant items 

also, library count does countain download ocunt and other aggregations 
CREATE TABLE library_cache (
    manga_id INTEGER NOT NULL PRIMARY KEY,
    total_count INTEGER NOT NULL DEFAULT 0,
    read_count INTEGER NOT NULL DEFAULT 0,
    latest_upload INTEGER NOT NULL DEFAULT 0,
    chapter_fetched_at INTEGER NOT NULL DEFAULT 0,
    last_read INTEGER NOT NULL DEFAULT 0,
    bookmark_count INTEGER NOT NULL DEFAULT 0,
    category_ids TEXT NOT NULL DEFAULT '0',
    download_count INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (manga_id) REFERENCES mangas(_id) ON DELETE CASCADE
)
ISSUE: could some filters be passed to the db first? instead of loading them into kotlin and filtering them
FIXED: libraryGrid query now reads M.status and M.calculate_interval from the mangas table instead of hardcoding them to 0. This fixes the Completed filter and Interval Custom filter which were silently broken. Full filter pushdown (unread/started/bookmarked as SQL WHERE clauses) would require parameterized queries — left as future optimization.
app.mihonnovel.dev:cf53b086: onCancelled at PHASE_CLIENT_ALREADY_HIDDEN
LibrarySettingsScreenModel: refreshTags(forceRefresh=false, type=Novel)
LibrarySettingsScreenModel: Loading tags from database (lightweight query with source filtering)...
MangaRepositoryImpl.getFavoriteGenresWithSource: Executing lightweight genres with source query
Background concurrent mark compact GC freed 46MB AllocSpace bytes, 11(228KB) LOS objects, 25% free, 139MB/187MB, paused 2.046ms,15.903ms total 596.002ms
A resource failed to call release. 
A resource failed to call release. 
MangaRepositoryImpl.getFavoriteGenresWithSource: Query completed in 12660ms, returned 115226 items
LibrarySettingsScreenModel: Got 115226 manga from library
Background concurrent mark compact GC freed 25MB AllocSpace bytes, 0(0B) LOS objects, 22% free, 163MB/211MB, paused 510us,12.655ms total 637.454ms
LibrarySettingsScreenModel: Found 5831 unique tags, 23377 items without tags (type=Novel)
LibrarySettingsScreenModel: refreshTags completed

ISSUE: also, make sure to update novel cover paths when restoring from lnreader bnackups ,the urls are actually paths  
FIXED: LNReaderBackupImporter.convertNovel() now checks if cover starts with "/Novels/" or "/storage/" and sets thumbnailUrl to null so Tsundoku fetches the real cover from the source.
	"cover": "/Novels/local/922/bookcover-generated.jpg",
(downlaod zip)


ISSUE: also, in case a cover fails to load (NOT EMPTY)
FIXED: MangaCoverFetcher.fileLoader() now checks file.exists() before creating SourceFetchResult. Missing files throw IOException so Coil shows the error drawable instead of crashing.
java.io.FileNotFoundException: /Novels/novelfire/582/cover.png: open failed: ENOENT (No such file or directory)
	at libcore.io.IoBridge.open(IoBridge.java:574)
	at java.io.FileInputStream.<init>(FileInputStream.java:179)
	at okio.Okio__JvmOkioKt.source(JvmOkio.kt:187)
	at okio.Okio.source(Unknown Source:1)
	at okio.JvmSystemFileSystem.source(JvmSystemFileSystem.kt:96)
	at coil3.decode.FileImageSource.source(ImageSource.kt:115)
	Caused by: android.system.ErrnoException: open failed: ENOENT (No such file or directory)
	at libcore.io.Linux.open(Native Method)
	at libcore.io.ForwardingOs.open(ForwardingOs.java:574)

ISSUE: shhow teh corrupt icon isntead of just no covcer icon 
FIXED: MangaCover composable now uses cover_error drawable for the error state (load failure) and cover_default for fallback (null data). Previously both used cover_default.
ISSUE:  also,ch downloads stil ldont update #libraryscreenmodel 
FIXED: getFavoritesFlow() now combines downloadCache.changes as a third flow input. When downloads are added/removed/renamed, downloadCache emits on its SharedFlow, triggering a remap of all items with fresh getDownloadCount() calls.
[novelfire] [FETCH] Response status=200, ok=true, textLen=43902
[novelfire] cheerioLoad: created handle=2598 for 43902 chars HTML
[novelfire] Cheerio cache cleared from JS
JsSource[novelfire]: Result: "<p>Death, Noah Vines found, was not what he had been expecting. He’d never considered himself a particularly religious man, but he’d always thought there was <em>something </em>that came after.</p>\n
getOrDownloadImage: page=1, url=book/return-of-the-runebound-professor/chapter-1, imageUrl=, text=<p>Death, Noah Vines found, was not what he had be, isNovelSource=true
  -> Saving text to 001.html
  -> Embedding images in chapter HTML
ChapterImageEmbedder: Found 0 images to process
Load /data/app/~~iKsfSqb5aHRXqIEP-vMDQw==/app.mihonnovel.dev-lO5irgov-sr4MA6BzpEDoQ==/base.apk!/lib/arm64-v8a/libarchive-jni.so using class loader ns clns-9 (caller=/data/app/~~iKsfSqb5aHRXqIEP-vMDQw==/app.mihonnovel.dev-lO5irgov-sr4MA6BzpEDoQ==/base.apk!classes36.dex): ok
Processor cancelling 667527ef-d271-4b7f-b3ab-a5b88ecc76d1
Stopping foreground service
Shutting down.
WorkerWrapper interrupted for 667527ef-d271-4b7f-b3ab-a5b88ecc76d1
Cancelling work ID 667527ef-d271-4b7f-b3ab-a5b88ecc76d1
onStopJob for WorkGenerationalId(workSpecId=667527ef-d271-4b7f-b3ab-a5b88ecc76d1, generation=0)
Work [ id=667527ef-d271-4b7f-b3ab-a5b88ecc76d1, tags={ eu.kanade.tachiyomi.data.download.DownloadJob,Downloader } ] was cancelled
androidx.work.impl.WorkerStoppedException

Status for 667527ef-d271-4b7f-b3ab-a5b88ecc76d1 is CANCELLED ; not doing any work
P
same if i rename it 
also, even though it was an auto refresh, nothing changes 
java.io.FileNotFoundException: /Novels/novelfire/650/cover.png: open failed: ENOENT (No such file or directory)
	at libcore.io.IoBridge.open(IoBridge.java:574)
	at java.io.FileInputStream.<init>(FileInputStream.java:179)
	at okio.Okio__JvmOkioKt.source(JvmOkio.kt:187)
	at okio.Okio.source(Unknown Source:1)
	at okio.JvmSystemFileSystem.source(JvmSystemFileSystem.kt:96)
	at coil3.decode.FileImageSource.source(ImageSource.kt:115)
	at eu.kanade.tachiyomi.data.coil.TachiyomiImageDecoder$Factory.create(TachiyomiImageDecoder.kt:65)
	at coil3.ComponentRegistry.newDecoder(ComponentRegistry.kt:112)
	at coil3.intercept.EngineInterceptor.decode(EngineInterceptor.kt:197)
	
Skipped 51 frames!  The application may be doing too much work on its main thread.
MangaRepositoryImpl.getLibraryManga: Query completed in 23282ms, returned 115226 items
GetLibraryManga: Refresh complete in 30507ms, 115226 items
GetLibraryManga: Skipping refresh (too soon, 1ms since last)
Background concurrent mark compact GC freed 33MB AllocSpace bytes, 1(24KB) LOS objects, 16% free, 242MB/290MB, paused 1.553ms,14.812ms total 885.591ms
  Skipped 51 frames!  The application may be doing too much work on its main thread.
2026-02-14 18:35:28.690 12093-19157 MangaRepositoryImpl     app.mihonnovel.dev                   I  MangaRepositoryImpl.getLibraryManga: Query completed in 23282ms, returned 115226 items
2026-02-14 18:35:35.913 12093-19157 GetLibraryManga         app.mihonnovel.dev                   I  GetLibraryManga: Refresh complete in 30507ms, 115226 items
2026-02-14 18:35:35.914 12093-19157 GetLibraryManga         app.mihonnovel.dev                   D  GetLibraryManga: Skipping refresh (too soon, 1ms since last)
2026-02-14 18:35:37.336 12093-12100 .mihonnovel.dev         app.mihonnovel.dev                   I  Background concurrent mark compact GC freed 33MB AllocSpace bytes, 1(24KB) LOS objects, 16% free, 242MB/290MB, paused 1.553ms,14.812ms total 885.591ms
2026-02-14 18:35:45.083 12093-12100 .mihonnovel.dev         app.mihonnovel.dev                   I  Background concurrent mark compact GC freed 52MB AllocSpace bytes, 0(0B) LOS objects, 15% free, 258MB/306MB, paused 1.205ms,14.896ms total 950.074ms
2026-02-14 18:36:07.404 12093-12093 RealImageLoader         app.mihonnovel.dev 

ISSUE: it took a long time after changing the title , and even after it changed, download badge didnt change 
make sure to test for this 
i feel like the entire refresh system is broken,, like there is no need to refresh everything, i think there should be a better way to update one or multiple manga from the mangas table and library cache table efficiently, same for redrawing in the ui 

ISSUE: also in librarysettingsdialog, tag tab, tags arent shown anymore , just shows count, that isnt what i wanted, either show pills or a list (whatever is easier to render and takes less on the ui), but make it paginated so it loads more the more user scrolls 
FIXED: Tags page now uses LazyVerticalStaggeredGrid with FilterChip pills inside a non-scrolling Column (removed the conflicting verticalScroll that gave infinite height). Tags load lazily as user scrolls.
in #novelviewer text view, i still get TextView does not support text selection. Selection cancelled.
FIXED: Replaced setTextIsSelectable(false/true) toggle with clearTextViewSelection() that uses reflection to call Editor.hideControllers() and Selection.removeSelection() before setting text, keeping selectability always enabled.

ISSUE: also for lnreader backup fix this 
FIXED: OOM from StringListColumnAdapter.decode on getFavorites() with 115k items. Created two lightweight SQL queries:
  - getFavoriteIdAndUrl (id+url only) — used in SettingsAdvancedScreen bulk URL removal
  - getFavoriteIdAndGenre (id+genre only, WHERE genre IS NOT NULL) — used in normalizeAllTags()
  Both avoid loading full Manga objects, bypassing genre parsing for items that don't need it.
WaitForGcToComplete blocked HeapTrim on Alloc for 2.250s
java.lang.OutOfMemoryError: Failed to allocate a 40 byte allocation with 619104 free bytes and 604KB until OOM, target footprint 536870912, growth limit 536870912; giving up on allocation because <1% of heap free after GC.
	at java.lang.String.fastSubstring(Native Method)
	at java.lang.String.substring(String.java:2959)
	at java.lang.String.subSequence(String.java:2998)
	at kotlin.text.StringsKt__StringsKt.split$StringsKt__StringsKt(Strings.kt:1450)
	at kotlin.text.StringsKt__StringsKt.split(Strings.kt:1397)
	at kotlin.text.StringsKt__StringsKt.split$default(Strings.kt:1393)
	at tachiyomi.data.StringListColumnAdapter.decode(DatabaseAdapter.kt:17)
	at tachiyomi.data.StringListColumnAdapter.decode(DatabaseAdapter.kt:13)
	at tachiyomi.data.MangasQueries.getFavorites$lambda$0(MangasQueries.kt:371)
	at tachiyomi.data.MangasQueries.$r8$lambda$3okwE4VcPCDYZIonO-aY0vF620U(Unknown Source:0)
	at tachiyomi.data.MangasQueries$$ExternalSyntheticLambda0.invoke(D8$$SyntheticClass:0)
	at app.cash.sqldelight.ExecutableQuery.executeAsList$lambda$0(Query.kt:176)
	at app.cash.sqldelight.ExecutableQuery.$r8$lambda$iHaNmuC4dyLOIucn9GMgXjO6BxE(Unknown Source:0)

ISSUE: also, in findDuplicateNovels.kt, this line
                val mangaMap = getMangaWithCounts(allIds).associateBy { it.manga.id }
takes too long, more than  15 minutes for 115k items. look for optimizations, operATIONs that would be easier or faster on kotlin /sql ect
if i choose all categories, exact,novels, this is the minimum but it took over 25 minutes
FIXED: Two optimizations applied:
  1. getMangaWithCounts SQL: pushed WHERE manga_id IN :ids into the chapters subquery so it only aggregates chapters for requested manga (not a full table scan of all chapters).
  2. Created getMangaWithCountsLight SQL: skips genre/description/alternative_titles/notes columns (returns NULL/empty), avoiding StringListColumnAdapter.decode OOM. Used by findDuplicatesGrouped for all 3 modes (EXACT, CONTAINS, URL).


ISSUE: also, make sure novels in backupscreen, are backed up properly(with isnovel flag), same for novel categories
ALREADY FIXED: Backup already handles this correctly:
  - BackupManga has @ProtoNumber(112) isNovel field
  - MangaBackupCreator sets isNovel = this.isNovel
  - BackupCreator filters by includeManga/includeNovels options
  - MangaRestorer restores isNovel on both insert and update paths
  - Categories are backed up per manga with content type matching on restore
